# 基础回顾
## 数据类型

### undefined 和 null 的区别

1. `null`表示没有对象， 即此处不应该有值

用法：
>(1) 作为函数的参数 表示 该函数的参数 不是对象
>(2) 作为原型链 的终点

`Object.getPrototypeOf(Object.prototype)` null

2. ``undefined` 表示缺少值， 就是此处应该有一个值， 但是还没有定义；

> 变量被声明了， 但是没有赋值， 等于 undefined
> 调用函数时， 没有传递相对应的参数， 则该参数 为undefined
> 对象没有赋值的属性， 该值的默认值为undefined
> 函数 没有返回值， 默认 返回undefined
> ![20220214005013](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220214005013.png)

**undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。因此，可以把undefined看作是空的变量，而null看作是空的对象**

## iife
立即执行函数

匿名函数字调用

```js
(function () {})()
```

不会污染 外部命名空间

![20220222201817](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220222201817.png)

$ 返回 一个对象， 再指向其中的test函数；

## 函数中this

一般模式模式下 为 window

- 所有函数中中都有一个变量 this

    他的值是调用函数的当前对象；

- 任何函数 都是通过对象来调用；

- 没有指定调用对象的时候， 函数的调用对象为window 

# 函数高级

## 原型和原型链 

函数的prototype属性

- 每个函数都有一个prototype ， 默认指向一个object 空对象，即原型对象；
```js
console.log(Date.prototype, typeof Date.prototype) // Object
```

- 原型对象中有一个属性 constructor 指向函数对象；

```js
console.log(Date.prototype.constructor===Date)
console.log(fn.prototype.constructor===fn) // true
```

- 构造函数和 原型对象 相互引用；

![20220222204750](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220222204750.png)

- 给原型对象添加属性 ==》示例对象可以访问


## 显示原型 和隐式原型

1. 每个函数function都有一个prototype，即显式原型, 默认指向 空的Object对象； 创建函数对象的时候，即定义函数的时候， 创建prototype属性
2. 每个实例对象都有一个__proto__，可称为隐式原型；创建对象的时候 添加
3. 对象的隐式对象的值 为对应的构造函数的显示原型的值

```js
function Fn() {
    // this.prototype = {}
}
var fn = new Fn() // 内部语句：this.__prototype__ = Fn.prototype
console.log(Fn.prototype, fn.__proto__)
console.log(Fn.prototype===fn.__proto__)  // true
```

![20220222205824](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220222205824.png)

两个 原型 都相当于 指针， 来指向在内存中新创建的 {} 空对象

只能操作 显式原型 而不能 修改 隐式原型；

## 原型链

![20220222214300](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220222214300.png)

现在自身属性中寻找， 再沿着 __prototype__ 向上寻找

原型链的尽头为 null

隐式 原型 

![20220222215421](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220222215421.png)

所有函数都有两个属性 


自身的显示原型 和自身的隐式原型 

![20220223162216](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220223162216.png)

## 原型继承

构造函数 的示例对象 自动拥有 构造函数的原型对象的属性 

Object.prototype.__prototype__ = null

对象的方法 放在 原型中

isstanceof 判断是否为 一个对象实例 是否为一个对象的实例；

如何判断？

A istanceof B: A为实例对象； B为构造函数 

通过隐式原型链  B的显示原型 再A对象的原型链上 就返回True

![20220223165218](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220223165218.png)

## 执行上下文

### 变量提升 和函数提升

通过 var声明的 变量， 在语句之前就可以访问到

![20220223171337](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220223171337.png)

定义 ， 但是 并没有执行复制操作，所以看到的是 undefined

![20220223171452](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220223171452.png)

函数 提升 必须使用函数声明的方式； 
```js
function f () {
    // 函数体
}
```

### 执行上下文

- 全局执行上下文
  * 在执行全局代码前将window确定为全局执行上下文
  * 对全局数据进行预处理
    * var定义的全局变量==>undefined, 添加为window的属性
    * function声明的全局函数==>赋值(fun), 添加为window的方法
    * this==>赋值(window)
  * 开始执行全局代码


- 函数执行上下文

  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
  * 对局部数据进行预处理
    * 形参变量==>赋值(实参)==>添加为执行上下文的属性
    * arguments==>赋值(实参列表), 添加为执行上下文的属性
    * var定义的局部变量==>undefined, 添加为执行上下文的属性
    * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
    * this==>赋值(调用函数的对象)
  * 开始执行函数体代码